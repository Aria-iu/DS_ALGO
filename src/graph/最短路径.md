# Dijkstra算法
**边上权值非负情形的单源最短路径问题**

给定一个带权有向图（即有向网）G和源点v0，求v0到G中其他每个顶点的最短路径。（限定各边上的权值大于或等于0。）

Dijkstra算法的具体实现方法如下。
1. 设置两个顶点的集合T和S。S中存放已找到最短路径的顶点，初始时，集合S中只有一个顶点，
即源点v0。T中存放当前还未找到最短路径的顶点。
2. 在T集合中选取当前长度最短的一条最短路径（v0
，…，vk），从而将vk 加入到顶点集合S中，并修改源点v0 到T中各顶点的最短路径长度；重复这一步骤，直到所有的顶点都加入到集合S中，算法就结束了。

# Bellman-Ford算法
**边上权值为任意值的单源最短路径问题**

为了能够求解边上带有负权值的单源最短路径问题，Bellman（贝尔曼）和Ford（福特）提出了从源点逐次途经其他顶点，以缩短到达终点的最短路径长度的方法。**该方法也有一个限制条件：要求图中不能包含权值总和为负值的回路。**

# SPFA算法
Bellman-Ford算法的改进

Bellman-Ford算法的时间复杂度比较高，为O（n^3 ）或O（nm），原因在于Bellman-Ford算法要递推n次，每次递推，扫描所有的边，在递推n次的过程中很多判断是多余的。SPFA（Shortest Path Faster Algorithm）算法 是Bellman-Ford算法的一种队列实现，减少了不必要的冗余判断。

SPFA算法的大致流程是用一个队列来进行维护。初始时将源点加入队列。每次从队列中取出一个顶点，并对所有与它相邻的顶点进行松弛，若某个相邻的顶点松弛成功，则将其入队。重复这样的过程直到队列为空时算法结束。

# Floyd算法
所有顶点之间的最短路径

已知一个有向网（或无向网），对每一对顶点vi≠vj ，要求求出vi 与vj 之间的最短路径和最短路径长度。

**与Bellman-Ford算法类似，Floyd算法允许图中有带负权值的边，但不允许有包含负权值回路。**

Floyd（弗洛伊德）算法的基本思想是：对一个顶点个数为n的有向网（或无向网），设置一个n×n的方阵A（k），其中除对角线的矩阵元素都等于0外，其他元素A（k）［i］［j］（i≠j）表示从顶点vi 到顶点vj 的有向路径长度，k表示运算步骤，k＝-1，0，1，2，…，n－1。

初始时：A（-1） ＝Edge（图的邻接矩阵），即初始时，以任意两个顶点之间的直接有向边的权值作为最短路径长度。
1. 对于任意两个顶点vi 和vj ，若它们之间存在有向边，则以此边上的权值作为它们之间的最短路径长度。
2. 若它们之间不存在有向边，则以MAX作为它们之间的最短路径。

以后逐步尝试在原路径中加入其他顶点作为中间顶点，如果增加中间顶点后，得到的路径比原来的最短路径长度减少了，则以此新路径代替原路径，修改矩阵元素，更新为新的更短的路径长度。

1. A（-1）［i］［j］＝Edge［i］［j］
2. A（k）［i］［j］＝min｛A（k－1）［i］［j］，A（k－1）［i］［k］＋A（k－1）［k］［j］｝，k＝0，1，…，n－1

